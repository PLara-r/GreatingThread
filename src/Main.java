public class Main extends Thread {
    public void run() {
        System.out.println("Printing zoo inventory");
    }
    public static void main(String[] args) {
        System.out.println("begin");
        (new Main()).start();
        (new Thread(new PrintData())).start();
        (new Main()).start();
        System.out.println("end");
    }}

    //begin
//end
//Printing zoo inventory
//Printing record: 0
//Printing record: 1
//Printing record: 2
//Printing zoo inventory

//В этом примере используется всего четыре потока - main()пользовательский поток и три дополнительных потока,
// созданных main()методом.
// Хотя порядок выполнения потока после его запуска является неопределенным,
// порядок в пределах одного потока все еще является линейным.
// Например, for()цикл in PrintDataвсе еще упорядочен, как и endпосле метода beginin main().

//
//В целом, вы должны расширять Threadкласс только при очень специфических обстоятельствах,
// например, когда вы создаете свой собственный поток на основе приоритетов.
// В большинстве ситуаций вы должны реализовать Runnableинтерфейс, а не расширять Threadкласс.

//параметрами создания потоков
//•	Если вам нужно определить свои собственные Threadправила, на которые будут опираться несколько задач,
// например приоритет Thread, расширение Threadможет быть предпочтительным.

//•	Поскольку Java не поддерживает множественное наследование,
// расширение Threadне позволяет расширять какой-либо другой класс,
// тогда как реализация Runnableпозволяет расширять другой класс.

//•	Реализация Runnableчасто является лучшей практикой объектно-ориентированного проектирования,
// поскольку она отделяет выполняемую задачу от Threadвыполняющего ее объекта.

//•	Реализация Runnableпозволяет использовать этот класс множеством Concurrencyклассов API.

// и !!! теперь вы можете использовать  ExecutorService, что мы обсудим в следующем разделе,
// для выполнения задач потока
// без необходимости Threadнепосредственного создания объектов.
