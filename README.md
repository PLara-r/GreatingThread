# GreatingThread

Как вы узнаете из главы 8 «IO» и главы 10 «JDBC», компьютеры способны считывать и записывать данные на внешние ресурсы.
К сожалению, по сравнению с операциями с ЦП, эти операции с диском / сетью имеют тенденцию быть чрезвычайно медленными. На самом деле настолько медленный, 
что если операционная система вашего компьютера остановится и будет ждать завершения каждой операции диска или сети,
ваш компьютер будет постоянно зависать или зависать.
К счастью, все современные операционные системы поддерживают так называемую многопоточную обработку. Идея многопоточной обработки заключается в том, 
чтобы приложение или группа приложений могли выполнять несколько задач одновременно. Это позволяет задачам, ожидающим других ресурсов, уступить место другим запросам обработки.
С самого начала Java поддерживала многопоточное программирование с использованием Threadкласса.
В 2004 году была выпущена Java 5 и ConcurrencyAPI был представлен в java.util.concurrentпакете. В него вошли многочисленные классы для выполнения сложных задач на основе потоков.
Идея была проста: управлять сложными взаимодействиями потоков довольно сложно даже для самых опытных разработчиков; поэтому был создан набор повторно используемых функций. 

1). ThreadКласс включает в себя три важных staticконстант, как показано в таблице
7.1 . По умолчанию пользовательские потоки получают значение приоритета потока Thread.NORM_PRIORITY.
Если у вас есть поток, который должен быть выполнен сразу же, вы можете увеличить это значение до 6или выше или использовать это Thread.MAX_PRIORITYзначение. 
Если два потока имеют одинаковый приоритет, планировщик потока будет произвольно выбирать тот, который будет обрабатываться первым в большинстве ситуаций.
Таблица 7.1 Константы приоритета потока Java

Constant Variable
Постоянная переменная	Value
Ценность
Thread.MIN_PRIORITY	1
Thread.NORM_PRIORITY	5
Thread.MAX_PRIORITY	10

Важность планирования потоков

Несмотря на то, что многоядерные процессоры довольно распространены в наши дни, одноядерные процессоры были стандартом в области
персональных компьютеров на протяжении многих десятилетий. За это время операционные системы разработали сложные алгоритмы планирования потоков 
и переключения контекста, которые позволяли пользователям выполнять десятки или даже сотни потоков в одноядерной системе ЦП.
Эти алгоритмы планирования позволили пользователям создать иллюзию того, что несколько задач выполнялись одновременно в одной системе ЦП.
Например, пользователь может слушать музыку во время написания статьи и получать уведомления о новых сообщениях.
Поскольку число потоков часто намного превышает число процессоров, доступных даже в многоядерных системах,
эти алгоритмы планирования потоков все еще используются в операционных системах сегодня.

2) Представляем Runnable

Как мы упоминали в главе 4, «Функциональное программирование» java.lang.Runnable, или Runnableдля краткости, 
- это функциональный интерфейс, который не принимает аргументов и не возвращает данных. Ниже приведено определение Runnableинтерфейса:
@FunctionalInterface public interface Runnable { 
  void run();
}
RunnableИнтерфейс обычно используется для определения работы потока будет выполняться, отдельно от основного приложения потока. 
В Runnableэтой главе мы будем полагаться на интерфейс, особенно когда будем обсуждать применение параллельных операций к потокам.
Каждое из следующих лямбда-выражений зависит от Runnableинтерфейса:


() -> System.out.println("Hello World")
() -> {int i=10; i++;}
() -> {return;}
() -> {}
Обратите внимание, что все эти лямбда-выражения начинаются с набора пустых скобок (). Также обратите внимание, что ни один из них не возвращает значение.
По этим причинам следующие лямбды, хотя и допустимы для других функциональных интерфейсов, не совместимы с Runnable:

() -> ""
() -> 5
() -> {return new Object();}
Эти примеры являются недопустимыми Runnableвыражениями, поскольку каждое из них возвращает значение.
Создание исполняемых классов
Несмотря на то, Runnableчто в Java 8 был создан функциональный интерфейс, этот интерфейс Runnableсуществует с самой первой версии Java. 
Он был и до сих пор широко используется для определения задачи потока путем создания класса, реализующего Runnableинтерфейс, как показано в следующем коде:
public class CalculateAverage implements Runnable {
   public void run() {    
     // Define work here  
 }}
Это также полезно, если вам нужно передать информацию в ваш Runnableобъект для использования run()методом, например, в следующем конструкторе класса:

public class CalculateAverages implements Runnable { 
  private double[] scores; 
  public CalculateAverages(double[] scores) {  
    this.scores = scores; 
  } 
  public void run() {  
    // Define work here that uses the scores object 
  }}
В этой главе мы сосредоточимся на создании лямбда-выражений, которые неявно реализуют Runnableинтерфейс. 
Просто имейте в виду, что он обычно используется в определениях классов.

3)Creating a Thread
Создание  нитей

Самый простой способ выполнить поток - использовать java.lang.Threadкласс или Threadдля краткости.
Выполнение задачи с Threadпомощью двухэтапного процесса. Сначала вы определяете Threadс соответствующей задачей, которая будет выполнена. 
Затем вы запускаете задачу, используя Thread.start()метод.
Как мы обсудим позже в этой главе, Java не предоставляет никаких гарантий относительно порядка, в котором поток будет обрабатываться после его запуска.
Это может быть выполнено немедленно или задержано в течение значительного количества времени.
Помните, что порядок выполнения потока часто не гарантируется. Экзамен обычно представляет вопросы, в которых несколько заданий запускаются одновременно,
и вы должны определить результат.
Определить задачу или работу, которую Threadбудет выполнять экземпляр, можно в Java двумя способами:
•	Предоставить Runnableобъект или лямбда-выражение Threadконструктору.
•	Создайте класс, который расширяет Threadи переопределяет run()метод.Ниже приведены примеры этих методов:
Ниже приведены примеры этих методов:

public class PrintData implements Runnable { 
  public void run() {   
   for(int i=0; i<3; i++)   
      System.out.println("Printing record: "+i); 
  } 
  public static void main(String[] args) { 
     (new Thread(new PrintData())).start(); 
  }}
  //Printing record: 0
Printing record: 1
Printing record: 2
  
public class ReadInventoryThread extends Thread {  
 public void run() {
      System.out.println("Printing zoo inventory"); 
  }  
 public static void main(String[] args) { 
     (new ReadInventoryThread()).start();
  }}
  //
Printing zoo inventory


Первый пример создает Threadиспользование Runnableэкземпляра, тогда как второй пример использует менее распространенную практику 
расширения Threadкласса и переопределения run()
метода. Каждый раз, когда вы создаете Threadэкземпляр, не забудьте запустить задачу с помощью Thread.start()метода.
Это запускает задачу в отдельном потоке операционной системы. Например, каков вывод следующего фрагмента кода с использованием этих двух классов?

public static void main(String[] args) {
   System.out.println("begin"); 
  (new ReadInventoryThread()).start(); 
  (new Thread(new PrintData())).start(); 
  (new ReadInventoryThread()).start(); 
  System.out.println("end");
}
Ответ в том, что он неизвестен до времени выполнения. Например, следующее является лишь одним из возможных выходных данных:
Begin
Printing zoo inventory
Printing record: 0
end
Printing zoo inventory
Printing record: 1
Printing record: 2
В этом примере используется всего четыре потока - main()пользовательский поток и три дополнительных потока, созданных main()методом.
Хотя порядок выполнения потока после его запуска является неопределенным, порядок в пределах одного потока все еще является линейным.
Например, for()цикл in PrintDataвсе еще упорядочен, как и endпосле метода beginin main().

4) Опрос со сном

Часто вам нужен поток для опроса, чтобы закончить результат. Pollingэто процесс периодической проверки данных через некоторый фиксированный интервал.
Например, предположим, что у вас есть поток, который изменяет общее static counterзначение, и ваш main()поток ожидает, пока поток увеличит указанное выше значение 100,
как показано в следующем классе:

public class CheckResults { 
  private static int counter = 0;  
 public static void main(String[] args) {  
    new Thread(() -> {    
     for(int i=0; i<500; i++) CheckResults.counter++;  
    }).start();  
    while(CheckResults.counter<100) {    
     System.out.println("Not reached yet");    
  }     
 System.out.println("Reached!");  
 }}

Сколько раз while()цикл в этом коде будет выполняться и выводиться Not reached yet? Ответ: мы не знаем! Может выдать ноль, 
десять или миллион раз. Если наш планировщик потоков особенно плох, он может работать бесконечно! Использование while()цикла для проверки данных без каких-либо задержек
считается очень плохой практикой кодирования, так как без всяких причин связывает ресурсы ЦП.
Мы можем улучшить этот результат, используя Thread.sleep()метод для осуществления опроса. Thread.sleep()Метод запрашивает текущий поток
выполнения остальных в течение определенного количества миллисекунд. При использовании внутри тела main()метода связанный
с ним поток main()приостанавливается, а отдельный поток продолжает работать. Сравните предыдущую реализацию со следующей, которая использует Thread.sleep():

public class CheckResults { 
  private static int counter = 0;
   public static void main(String[] args) throws InterruptedException {  
    new Thread(() -> { 
        for(int i=0; i<500; i++) CheckResults.counter++;  
    }).start();  
    while(CheckResults.counter<100) {   
      System.out.println("Not reached yet");      
   Thread.sleep(1000); // 1 SECOND   
   }  
    System.out.println("Reached!");
   }}
В этом примере мы задерживаем 1000 миллисекунд в конце цикла или 1 секунду. Хотя это может показаться незначительным, мы теперь предотвратили
выполнение и блокировку нашей основной программы, возможно, бесконечным циклом. Обратите внимание, что мы также изменили сигнатуру основного метода, 
так как Thread.sleep()выбрасывает проверенный InterruptedException. В качестве альтернативы, мы могли бы обернуть каждый вызов Thread.sleep()метода в try/catchблок.
Сколько раз while()цикл выполняется в этом исправленном классе? Все еще неизвестно! Хотя опрос предотвращает переполнение ЦП потенциально бесконечным циклом,
он не гарантирует, когда цикл завершится. Например, отдельный поток может терять процессорное время процессу с более высоким приоритетом, 
что приводит к многократному выполнению while()цикла до его завершения.
Другая проблема, о которой следует беспокоиться - это counterпеременная общего доступа. Что если один поток читает counterпеременную, 
в то время как другой пишет ее? Поток, читающий переменную общего доступа, может в результате получить неверное или неправильное значение.
Мы подробно обсудим эти вопросы в следующем разделе о синхронизации.


